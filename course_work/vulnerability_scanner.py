#!/usr/bin/env python3
import socket
import threading
import queue
import ipaddress
import datetime
import json
import os
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import requests
import nmap
import csv
import webbrowser
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from random import randint
import time
import sys

class VulnerabilityDatabase:
    def __init__(self, local_db_path="vulnerability_db.json"):
        self.local_db_path = local_db_path
        self.load_local_database()
        
    def load_local_database(self):
        try:
            if os.path.exists(self.local_db_path):
                with open(self.local_db_path, 'r') as f:
                    self.local_db = json.load(f)
            else:
                self.local_db = {
                    "vsFTPd 2.3.4": {
                        "cve": "CVE-2011-2523",
                        "description": "Backdoor vulnerability",
                        "severity": "HIGH"
                    },
                    "Apache httpd 2.2.8": {
                        "cve": ["CVE-2007-6421", "CVE-2008-0455"],
                        "description": "Multiple vulnerabilities",
                        "severity": "MEDIUM"
                    },
                    "OpenSSH 7.2p1": {
                        "cve": "CVE-2016-6210",
                        "description": "User enumeration vulnerability",
                        "severity": "MEDIUM"
                    },
                    "ProFTPD 1.3.5": {
                        "cve": "CVE-2015-3306",
                        "description": "Remote command execution",
                        "severity": "CRITICAL"
                    }
                }
                self.save_local_database()
        except Exception as e:
            print(f"Error loading local database: {e}")
            self.local_db = {}
    
    def save_local_database(self):
        with open(self.local_db_path, 'w') as f:
            json.dump(self.local_db, f, indent=4)
    
    def check_vulnerability(self, banner):
        results = []
        for vuln_banner, details in self.local_db.items():
            if vuln_banner.lower() in banner.lower():
                results.append({
                    "banner": vuln_banner,
                    "details": details
                })
        
        if not results:
            try:
                service_info = banner.split()[0]
                results = self.query_nvd_api(service_info)
            except:
                pass
                
        return results
    
    def query_nvd_api(self, service_info):
        try:
            api_url = f"https://services.nvd.nist.gov/rest/json/cves/1.0?keyword={service_info}"
            response = requests.get(api_url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                results = []
                for item in data.get("result", {}).get("CVE_Items", [])[:5]:
                    cve_id = item.get("cve", {}).get("CVE_data_meta", {}).get("ID")
                    desc = item.get("cve", {}).get("description", {}).get("description_data", [{}])[0].get("value", "")
                    severity = item.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {}).get("baseSeverity", "UNKNOWN")
                    
                    results.append({
                        "banner": service_info,
                        "details": {
                            "cve": cve_id,
                            "description": desc[:100] + "...",
                            "severity": severity
                        }
                    })
                return results
        except Exception as e:
            print(f"Error querying NVD API: {e}")
        return []
    
    def add_vulnerability(self, banner, cve, description, severity):
        self.local_db[banner] = {
            "cve": cve,
            "description": description,
            "severity": severity
        }
        self.save_local_database()

class NetworkScanner:
    def __init__(self, callback=None, max_threads=100):
        self.queue = queue.Queue()
        self.results = {}
        self.active = False
        self.callback = callback
        self.max_threads = max_threads
        self.vuln_db = VulnerabilityDatabase()
        self.nm = nmap.PortScanner()
        
    def discover_hosts(self, network_range):
        try:
            discovered_hosts = []
            self.nm.scan(hosts=network_range, arguments='-sn')
            for host in self.nm.all_hosts():
                discovered_hosts.append(host)
            return discovered_hosts
        except Exception as e:
            print(f"Error in host discovery: {e}")
            hosts = []
            try:
                network = ipaddress.ip_network(network_range, strict=False)
                for ip in network.hosts():
                    ip_str = str(ip)
                    response = os.system(f"ping -c 1 -W 1 {ip_str} > /dev/null 2>&1")
                    if response == 0:
                        hosts.append(ip_str)
            except Exception as e:
                print(f"Error in ping discovery: {e}")
            return hosts
    
    def scan_port(self, ip, port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((ip, port))
            
            if result == 0:
                try:
                    sock.send(b'HELLO\r\n')
                    banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                except:
                    try:
                        self.nm.scan(ip, str(port))
                        service = self.nm[ip]['tcp'][port]['name']
                        version = self.nm[ip]['tcp'][port]['product'] + " " + self.nm[ip]['tcp'][port]['version']
                        banner = f"{service} {version}".strip()
                    except:
                        banner = "Unknown service"
                
                vulnerabilities = self.vuln_db.check_vulnerability(banner)
                
                return {
                    "status": "open",
                    "banner": banner,
                    "vulnerabilities": vulnerabilities
                }
            else:
                return {"status": "closed"}
        except Exception as e:
            return {"status": "error", "error": str(e)}
        finally:
            try:
                sock.close()
            except:
                pass
    
    def worker(self):
        while self.active:
            try:
                ip, port = self.queue.get(timeout=1)
                result = self.scan_port(ip, port)
                
                if ip not in self.results:
                    self.results[ip] = {}
                
                self.results[ip][port] = result
                
                if self.callback:
                    self.callback(ip, port, result)
                
                self.queue.task_done()
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Worker error: {e}")
    
    def scan(self, targets, port_range=(1, 1024)):
        if isinstance(targets, str):
            if '/' in targets:
                targets = self.discover_hosts(targets)
            else:
                targets = [targets]
        
        self.results = {}
        self.active = True
        
        threads = []
        for _ in range(min(self.max_threads, len(targets) * (port_range[1] - port_range[0] + 1))):
            t = threading.Thread(target=self.worker)
            t.daemon = True
            t.start()
            threads.append(t)
        
        for ip in targets:
            for port in range(port_range[0], port_range[1] + 1):
                self.queue.put((ip, port))
        
        self.queue.join()
        
        self.active = False
        for t in threads:
            t.join()
        
        return self.results
    
    def stop_scan(self):
        self.active = False

class ScanReporter:
    
    @staticmethod
    def generate_txt_report(results, filename):
        with open(filename, 'w') as f:
            f.write("Vulnerability Scan Report\n")
            f.write("========================\n")
            f.write(f"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            
            for ip, ports in results.items():
                f.write(f"Host: {ip}\n")
                f.write("-" * 50 + "\n")
                
                open_ports = {p: d for p, d in ports.items() if d.get('status') == 'open'}
                if not open_ports:
                    f.write("No open ports found.\n\n")
                    continue
                
                for port, data in open_ports.items():
                    f.write(f"Port {port}: {data.get('banner', 'Unknown')}\n")
                    
                    if data.get('vulnerabilities'):
                        f.write("  Vulnerabilities:\n")
                        for vuln in data['vulnerabilities']:
                            details = vuln['details']
                            cve = details.get('cve', 'N/A')
                            if isinstance(cve, list):
                                cve = ", ".join(cve)
                            f.write(f"    - {cve}: {details.get('description')} (Severity: {details.get('severity')})\n")
                    f.write("\n")
                f.write("\n")
    
    @staticmethod
    def generate_csv_report(results, filename):
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['IP', 'Port', 'Status', 'Banner', 'CVE', 'Description', 'Severity'])
            
            for ip, ports in results.items():
                for port, data in ports.items():
                    if data.get('status') == 'open':
                        if data.get('vulnerabilities'):
                            for vuln in data['vulnerabilities']:
                                details = vuln['details']
                                cve = details.get('cve', 'N/A')
                                if isinstance(cve, list):
                                    cve = ", ".join(cve)
                                writer.writerow([
                                    ip,
                                    port,
                                    'Open',
                                    data.get('banner', 'Unknown'),
                                    cve,
                                    details.get('description', 'N/A'),
                                    details.get('severity', 'N/A')
                                ])
                        else:
                            writer.writerow([
                                ip,
                                port,
                                'Open',
                                data.get('banner', 'Unknown'),
                                'N/A',
                                'No vulnerabilities found',
                                'N/A'
                            ])
    
    @staticmethod
    def generate_html_report(results, filename):
        html = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Scan Report</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                h1 { color: #2c3e50; }
                .host { margin-bottom: 30px; }
                .host-header { background-color: #3498db; color: white; padding: 10px; border-radius: 5px; }
                .port { margin: 10px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }
                .vulnerable { border-left: 5px solid #e74c3c; }
                .safe { border-left: 5px solid #2ecc71; }
                .vuln-item { margin: 5px 0; padding: 5px; background-color: #f9f9f9; }
                .critical { color: #e74c3c; font-weight: bold; }
                .high { color: #e67e22; font-weight: bold; }
                .medium { color: #f39c12; }
                .low { color: #27ae60; }
                .meta { color: #7f8c8d; font-size: 0.9em; }
            </style>
        </head>
        <body>
            <h1>Vulnerability Scan Report</h1>
            <p class="meta">Date: %s</p>
        """ % datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        for ip, ports in results.items():
            html += f'<div class="host"><div class="host-header">Host: {ip}</div>'
            
            open_ports = {p: d for p, d in ports.items() if d.get('status') == 'open'}
            if not open_ports:
                html += '<p>No open ports found.</p>'
            else:
                for port, data in open_ports.items():
                    vuln_class = "vulnerable" if data.get('vulnerabilities') else "safe"
                    html += f'<div class="port {vuln_class}">'
                    html += f'<h3>Port {port}: {data.get("banner", "Unknown")}</h3>'
                    
                    if data.get('vulnerabilities'):
                        html += '<div class="vulnerabilities">'
                        for vuln in data['vulnerabilities']:
                            details = vuln['details']
                            severity = details.get('severity', 'UNKNOWN').lower()
                            cve = details.get('cve', 'N/A')
                            if isinstance(cve, list):
                                cve = ", ".join(cve)
                            
                            html += f'<div class="vuln-item">'
                            html += f'<span class="{severity}">{cve}</span>: {details.get("description")}'
                            html += f' (Severity: <span class="{severity}">{details.get("severity", "N/A")}</span>)'
                            html += '</div>'
                        html += '</div>'
                    else:
                        html += '<p>No vulnerabilities found.</p>'
                    
                    html += '</div>'
            
            html += '</div>'
        
        html += """
        </body>
        </html>
        """
        
        with open(filename, 'w') as f:
            f.write(html)

class VulnerabilityScanner(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title("Advanced Vulnerability Scanner")
        self.geometry("1000x700")
        self.minsize(800, 600)
        
        self.scanner = NetworkScanner(callback=self.update_scan_results)
        self.current_scan_results = {}
        
        self.create_menu()
        self.create_widgets()
        self.setup_styles()
        
        self.scan_running = False
        self.scan_progress = 0
        
        current_time = "2025-07-26 10:49:53"
        version_label = tk.Label(self, text=f"Version 1.0.0 | Â© 2025 | Date: {current_time} | User: BishalMahato")
        version_label.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=2)
        
        self.update_status("Ready")
    
    def setup_styles(self):
        style = ttk.Style()
        style.configure("TNotebook", background="#f0f0f0")
        style.configure("TFrame", background="#ffffff")
        style.configure("Critical.TLabel", foreground="#e74c3c", font=("Arial", 10, "bold"))
        style.configure("High.TLabel", foreground="#e67e22", font=("Arial", 10, "bold"))
        style.configure("Medium.TLabel", foreground="#f39c12", font=("Arial", 10))
        style.configure("Low.TLabel", foreground="#27ae60", font=("Arial", 10))
    
    def create_menu(self):
        menubar = tk.Menu(self)
        
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="New Scan", command=self.start_scan)
        file_menu.add_command(label="Stop Scan", command=self.stop_scan)
        file_menu.add_separator()
        file_menu.add_command(label="Export Results", command=self.export_results)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.quit)
        menubar.add_cascade(label="File", menu=file_menu)
        
        tools_menu = tk.Menu(menubar, tearoff=0)
        tools_menu.add_command(label="Network Discovery", command=self.network_discovery)
        tools_menu.add_command(label="Vulnerability Database", command=self.vulnerability_database)
        tools_menu.add_separator()
        tools_menu.add_command(label="Preferences", command=self.show_preferences)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="Documentation", command=self.show_documentation)
        help_menu.add_command(label="About", command=self.show_about)
        menubar.add_cascade(label="Help", menu=help_menu)
        
        self.config(menu=menubar)
    
    def create_widgets(self):
        main_frame = ttk.Frame(self, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        top_frame = ttk.Frame(main_frame)
        top_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(top_frame, text="Target:").pack(side=tk.LEFT, padx=(0, 5))
        self.target_var = tk.StringVar()
        self.target_entry = ttk.Entry(top_frame, textvariable=self.target_var, width=40)
        self.target_entry.pack(side=tk.LEFT, padx=(0, 10))
        
        ttk.Label(top_frame, text="Port Range:").pack(side=tk.LEFT, padx=(0, 5))
        self.start_port_var = tk.StringVar(value="1")
        self.end_port_var = tk.StringVar(value="1024")
        ttk.Entry(top_frame, textvariable=self.start_port_var, width=6).pack(side=tk.LEFT)
        ttk.Label(top_frame, text="-").pack(side=tk.LEFT, padx=2)
        ttk.Entry(top_frame, textvariable=self.end_port_var, width=6).pack(side=tk.LEFT, padx=(0, 10))
        
        self.scan_button = ttk.Button(top_frame, text="Start Scan", command=self.start_scan)
        self.scan_button.pack(side=tk.LEFT, padx=5)
        
        self.stop_button = ttk.Button(top_frame, text="Stop", command=self.stop_scan, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=(0, 10))
        
        self.status_var = tk.StringVar(value="Ready")
        status_frame = ttk.Frame(main_frame)
        status_frame.pack(fill=tk.X, side=tk.BOTTOM, pady=(10, 0))
        ttk.Label(status_frame, text="Status:").pack(side=tk.LEFT, padx=(0, 5))
        ttk.Label(status_frame, textvariable=self.status_var).pack(side=tk.LEFT, fill=tk.X)
        
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        self.results_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.results_frame, text="Scan Results")
        
        columns = ("ip", "port", "status", "banner", "vulnerabilities")
        self.results_tree = ttk.Treeview(self.results_frame, columns=columns, show="headings")
        
        self.results_tree.heading("ip", text="IP Address")
        self.results_tree.heading("port", text="Port")
        self.results_tree.heading("status", text="Status")
        self.results_tree.heading("banner", text="Service")
        self.results_tree.heading("vulnerabilities", text="Vulnerabilities")
        
        self.results_tree.column("ip", width=120)
        self.results_tree.column("port", width=60)
        self.results_tree.column("status", width=80)
        self.results_tree.column("banner", width=200)
        self.results_tree.column("vulnerabilities", width=400)
        
        scrollbar = ttk.Scrollbar(self.results_frame, orient=tk.VERTICAL, command=self.results_tree.yview)
        self.results_tree.configure(yscroll=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.results_tree.bind("<Double-1>", self.show_vulnerability_details)
        
        self.stats_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.stats_frame, text="Statistics")
        
        self.figure = Figure(figsize=(5, 4), dpi=100)
        self.plot = self.figure.add_subplot(111)
        
        self.canvas = FigureCanvasTkAgg(self.figure, master=self.stats_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        self.log_frame = ttk.Frame(self.notebook)
        self.notebook.add(self.log_frame, text="Log")
        
        self.log_text = scrolledtext.ScrolledText(self.log_frame, wrap=tk.WORD)
        self.log_text.pack(fill=tk.BOTH, expand=True)
        self.log_text.config(state=tk.DISABLED)
    
    def update_status(self, message):
        self.status_var.set(message)
        self.update_idletasks()
        
        self.log(message)
    
    def log(self, message):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"[{timestamp}] {message}\n"
        
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, log_message)
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
    
    def start_scan(self):
        if self.scan_running:
            messagebox.showwarning("Scan in Progress", "A scan is already running. Please stop it first.")
            return
        
        target = self.target_var.get().strip()
        if not target:
            messagebox.showerror("Error", "Please enter a target IP address or network range.")
            return
        
        try:
            start_port = int(self.start_port_var.get())
            end_port = int(self.end_port_var.get())
            
            if start_port < 1 or start_port > 65535 or end_port < 1 or end_port > 65535:
                raise ValueError("Ports must be between 1 and 65535.")
            
            if start_port > end_port:
                raise ValueError("Start port must be less than or equal to end port.")
        except ValueError as e:
            messagebox.showerror("Error", f"Invalid port range: {str(e)}")
            return
        
        for item in self.results_tree.get_children():
            self.results_tree.delete(item)
        
        self.current_scan_results = {}
        self.scan_running = True
        self.scan_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.progress_var.set(0)
        
        self.update_status(f"Starting scan on {target} (ports {start_port}-{end_port})...")
        
        threading.Thread(target=self.run_scan, args=(target, (start_port, end_port))).start()
    
    def run_scan(self, target, port_range):
        try:
            if '/' in target:
                self.update_status(f"Discovering hosts in {target}...")
                hosts = self.scanner.discover_hosts(target)
                if not hosts:
                    self.update_status("No hosts found in the specified range.")
                    self.finish_scan()
                    return
                
                self.update_status(f"Found {len(hosts)} hosts. Starting scan...")
            else:
                hosts = [target]
            
            self.scanner.scan(hosts, port_range)
            
            self.after(1000, self.update_statistics)
            
            self.update_status("Scan completed.")
        except Exception as e:
            self.update_status(f"Error during scan: {str(e)}")
        finally:
            self.finish_scan()
    
    def update_scan_results(self, ip, port, result):
        self.current_scan_results.setdefault(ip, {})[port] = result
        
        if result['status'] == 'open':
            vuln_count = len(result.get('vulnerabilities', []))
            vuln_text = f"{vuln_count} found" if vuln_count > 0 else "None"
            
            severity = "low"
            if vuln_count > 0:
                for vuln in result['vulnerabilities']:
                    vuln_severity = vuln['details'].get('severity', '').lower()
                    if vuln_severity == 'critical' or vuln_severity == 'high':
                        severity = 'high'
                        break
                    elif vuln_severity == 'medium' and severity != 'high':
                        severity = 'medium'
            
            self.results_tree.insert("", "end", values=(
                ip, port, "Open", result.get('banner', 'Unknown'), vuln_text
            ), tags=(severity,))
            
            self.results_tree.tag_configure('high', background='#ffcccc')
            self.results_tree.tag_configure('medium', background='#ffffcc')
            self.results_tree.tag_configure('low', background='#ccffcc')
        
        self.progress_var.set(min(100, self.progress_var.get() + 0.1))
        
        self.update_idletasks()
    
    def update_statistics(self):
        if not self.scan_running:
            return
        
        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0}
        vuln_count = 0
        port_count = 0
        
        for ip, ports in self.current_scan_results.items():
            for port, data in ports.items():
                if data.get('status') == 'open':
                    port_count += 1
                    for vuln in data.get('vulnerabilities', []):
                        vuln_count += 1
                        severity = vuln['details'].get('severity', 'UNKNOWN')
                        severity_counts[severity] += 1
        
        self.plot.clear()
        if vuln_count > 0:
            labels = []
            sizes = []
            colors = []
            
            for severity, count in severity_counts.items():
                if count > 0:
                    labels.append(severity)
                    sizes.append(count)
                    if severity == "CRITICAL":
                        colors.append('#e74c3c')
                    elif severity == "HIGH":
                        colors.append('#e67e22')
                    elif severity == "MEDIUM":
                        colors.append('#f39c12')
                    elif severity == "LOW":
                        colors.append('#2ecc71')
                    else:
                        colors.append('#95a5a6')
            
            self.plot.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=90)
            self.plot.axis('equal')
            self.plot.set_title(f'Vulnerabilities by Severity (Total: {vuln_count})')
        else:
            self.plot.text(0.5, 0.5, 'No vulnerabilities found', 
                          horizontalalignment='center', verticalalignment='center')
            self.plot.axis('off')
        
        self.canvas.draw()
        
        self.after(2000, self.update_statistics)
    
    def stop_scan(self):
        if not self.scan_running:
            return
        
        self.scanner.stop_scan()
        self.update_status("Stopping scan...")
    
    def finish_scan(self):
        self.scan_running = False
        self.scan_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.progress_var.set(100)
        self.update_idletasks()
    
    def show_vulnerability_details(self, event):
        selection = self.results_tree.selection()
        if not selection:
            return
            
        item = selection[0]
        values = self.results_tree.item(item, "values")
        
        if len(values) < 5 or values[2] != "Open" or values[4] == "None":
            return
        
        ip = values[0]
        port = int(values[1])
        
        if ip in self.current_scan_results and port in self.current_scan_results[ip]:
            result = self.current_scan_results[ip][port]
            vulnerabilities = result.get('vulnerabilities', [])
            
            if not vulnerabilities:
                return
            
            detail_window = tk.Toplevel(self)
            detail_window.title(f"Vulnerabilities for {ip}:{port}")
            detail_window.geometry("600x400")
            detail_window.minsize(500, 300)
            
            frame = ttk.Frame(detail_window, padding="10")
            frame.pack(fill=tk.BOTH, expand=True)
            
            ttk.Label(frame, text=f"Service: {result.get('banner', 'Unknown')}", font=("Arial", 12, "bold")).pack(anchor="w", pady=(0, 10))
            
            vuln_frame = ttk.Frame(frame)
            vuln_frame.pack(fill=tk.BOTH, expand=True)
            
            canvas = tk.Canvas(vuln_frame)
            scrollbar = ttk.Scrollbar(vuln_frame, orient="vertical", command=canvas.yview)
            
            scrollable_frame = ttk.Frame(canvas)
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            for i, vuln in enumerate(vulnerabilities):
                details = vuln['details']
                severity = details.get('severity', 'UNKNOWN')
                
                vuln_item_frame = ttk.Frame(scrollable_frame, padding=5)
                vuln_item_frame.pack(fill=tk.X, pady=5)
                
                if i > 0:
                    ttk.Separator(scrollable_frame, orient='horizontal').pack(fill=tk.X, pady=5)
                
                cve = details.get('cve', 'N/A')
                if isinstance(cve, list):
                    cve = ", ".join(cve)
                
                style_name = f"{severity.lower().capitalize()}.TLabel" if severity.lower() in ['critical', 'high', 'medium', 'low'] else None
                
                ttk.Label(vuln_item_frame, text=f"CVE: {cve}", style=style_name).pack(anchor="w")
                ttk.Label(vuln_item_frame, text=f"Severity: {severity}").pack(anchor="w")
                ttk.Label(vuln_item_frame, text="Description:").pack(anchor="w", pady=(5, 0))
                
                desc_text = tk.Text(vuln_item_frame, wrap=tk.WORD, height=4)
                desc_text.insert("1.0", details.get('description', 'No description available.'))
                desc_text.config(state=tk.DISABLED)
                desc_text.pack(fill=tk.X, pady=5)
                
                if cve != 'N/A' and not isinstance(cve, list):
                    ttk.Button(
                        vuln_item_frame, 
                        text="Lookup CVE", 
                        command=lambda c=cve: webbrowser.open(f"https://nvd.nist.gov/vuln/detail/{c}")
                    ).pack(anchor="w")
    
    def export_results(self):
        if not self.current_scan_results:
            messagebox.showinfo("No Results", "There are no scan results to export.")
            return
        
        filetypes = [
            ("HTML Report", "*.html"),
            ("CSV File", "*.csv"),
            ("Text File", "*.txt")
        ]
        
        filepath = filedialog.asksaveasfilename(
            defaultextension=".html",
            filetypes=filetypes,
            title="Export Scan Results"
        )
        
        if not filepath:
            return
        
        try:
            if filepath.endswith('.html'):
                ScanReporter.generate_html_report(self.current_scan_results, filepath)
            elif filepath.endswith('.csv'):
                ScanReporter.generate_csv_report(self.current_scan_results, filepath)
            elif filepath.endswith('.txt'):
                ScanReporter.generate_txt_report(self.current_scan_results, filepath)
            
            self.update_status(f"Results exported to {filepath}")
            
            if messagebox.askyesno("Export Complete", f"Results exported to {filepath}. Open file?"):
                if sys.platform == 'darwin':
                    os.system(f"open {filepath}")
                elif sys.platform == 'win32':
                    os.system(f"start {filepath}")
                else:
                    os.system(f"xdg-open {filepath}")
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export results: {str(e)}")
    
    def network_discovery(self):
        dialog = tk.Toplevel(self)
        dialog.title("Network Discovery")
        dialog.geometry("400x300")
        dialog.minsize(400, 300)
        dialog.transient(self)
        dialog.grab_set()
        
        frame = ttk.Frame(dialog, padding="10")
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="Network Range (CIDR notation, e.g., 192.168.1.0/24):").pack(anchor="w", pady=(0, 5))
        network_var = tk.StringVar()
        ttk.Entry(frame, textvariable=network_var, width=30).pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(frame, text="Discovered Hosts:").pack(anchor="w", pady=(10, 5))
        
        results_text = scrolledtext.ScrolledText(frame, wrap=tk.WORD, height=10)
        results_text.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        progress_var = tk.StringVar(value="Ready")
        ttk.Label(frame, textvariable=progress_var).pack(anchor="w")
        
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        def discover():
            network = network_var.get().strip()
            if not network:
                messagebox.showerror("Error", "Please enter a network range.")
                return
            
            results_text.delete("1.0", tk.END)
            progress_var.set("Discovering hosts...")
            
            def run_discovery():
                try:
                    hosts = self.scanner.discover_hosts(network)
                    
                    dialog.after(0, lambda: update_results(hosts))
                except Exception as e:
                    dialog.after(0, lambda: progress_var.set(f"Error: {str(e)}"))
            
            def update_results(hosts):
                if hosts:
                    for host in hosts:
                        results_text.insert(tk.END, f"{host}\n")
                    progress_var.set(f"Found {len(hosts)} hosts.")
                else:
                    results_text.insert(tk.END, "No hosts found in the specified range.")
                    progress_var.set("Discovery completed. No hosts found.")
            
            threading.Thread(target=run_discovery).start()
        
        ttk.Button(button_frame, text="Discover", command=discover).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Close", command=dialog.destroy).pack(side=tk.RIGHT)
    
    def vulnerability_database(self):
        dialog = tk.Toplevel(self)
        dialog.title("Vulnerability Database")
        dialog.geometry("700x500")
        dialog.minsize(600, 400)
        dialog.transient(self)
        
        frame = ttk.Frame(dialog, padding="10")
        frame.pack(fill=tk.BOTH, expand=True)
        
        notebook = ttk.Notebook(frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        local_db_frame = ttk.Frame(notebook)
        notebook.add(local_db_frame, text="Local Database")
        
        ttk.Label(local_db_frame, text="Known Vulnerabilities:").pack(anchor="w", pady=(0, 5))
        
        columns = ("banner", "cve", "description", "severity")
        db_tree = ttk.Treeview(local_db_frame, columns=columns, show="headings")
        
        db_tree.heading("banner", text="Service Banner")
        db_tree.heading("cve", text="CVE ID")
        db_tree.heading("description", text="Description")
        db_tree.heading("severity", text="Severity")
        
        db_tree.column("banner", width=150)
        db_tree.column("cve", width=100)
        db_tree.column("description", width=250)
        db_tree.column("severity", width=80)
        
        scrollbar = ttk.Scrollbar(local_db_frame, orient=tk.VERTICAL, command=db_tree.yview)
        db_tree.configure(yscroll=scrollbar.set)
        
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        db_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, pady=(0, 10))
        
        for banner, details in self.scanner.vuln_db.local_db.items():
            cve = details.get('cve', 'N/A')
            if isinstance(cve, list):
                cve = ", ".join(cve)
            
            db_tree.insert("", "end", values=(
                banner, cve, details.get('description', 'N/A'), details.get('severity', 'N/A')
            ))
        
        button_frame = ttk.Frame(local_db_frame)
        button_frame.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Button(button_frame, text="Add New", command=lambda: self.add_vulnerability_dialog(dialog, db_tree)).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Delete Selected", command=lambda: self.delete_vulnerability(db_tree)).pack(side=tk.LEFT)
        
        search_frame = ttk.Frame(notebook)
        notebook.add(search_frame, text="Search CVE Database")
        
        ttk.Label(search_frame, text="Search for vulnerabilities (e.g., service name, version):").pack(anchor="w", pady=(0, 5))
        
        search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=search_var, width=50)
        search_entry.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Button(search_frame, text="Search", command=lambda: self.search_vulnerabilities(search_var.get(), search_results)).pack(anchor="w", pady=(0, 10))
        
        ttk.Label(search_frame, text="Search Results:").pack(anchor="w", pady=(5, 5))
        
        search_results = scrolledtext.ScrolledText(search_frame, wrap=tk.WORD)
        search_results.pack(fill=tk.BOTH, expand=True)
    
    def add_vulnerability_dialog(self, parent, tree_view):
        dialog = tk.Toplevel(parent)
        dialog.title("Add Vulnerability")
        dialog.geometry("400x300")
        dialog.minsize(400, 300)
        dialog.transient(parent)
        dialog.grab_set()
        
        frame = ttk.Frame(dialog, padding="10")
        frame.pack(fill=tk.BOTH, expand=True)
        
        ttk.Label(frame, text="Service Banner (e.g., 'Apache httpd 2.4.46'):").pack(anchor="w", pady=(0, 5))
        banner_var = tk.StringVar()
        ttk.Entry(frame, textvariable=banner_var, width=50).pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(frame, text="CVE ID (e.g., 'CVE-2020-1234'):").pack(anchor="w", pady=(0, 5))
        cve_var = tk.StringVar()
        ttk.Entry(frame, textvariable=cve_var, width=50).pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(frame, text="Description:").pack(anchor="w", pady=(0, 5))
        description_text = tk.Text(frame, height=4, width=50)
        description_text.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(frame, text="Severity:").pack(anchor="w", pady=(0, 5))
        severity_var = tk.StringVar()
        severity_combo = ttk.Combobox(frame, textvariable=severity_var, values=["CRITICAL", "HIGH", "MEDIUM", "LOW"])
        severity_combo.pack(fill=tk.X, pady=(0, 10))
        severity_combo.current(1)
        
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        def add_vulnerability():
            banner = banner_var.get().strip()
            cve = cve_var.get().strip()
            description = description_text.get("1.0", tk.END).strip()
            severity = severity_var.get()
            
            if not banner or not description:
                messagebox.showerror("Error", "Banner and description are required.")
                return
            
            self.scanner.vuln_db.add_vulnerability(banner, cve, description, severity)
            
            tree_view.insert("", "end", values=(
                banner, cve, description, severity
            ))
            
            dialog.destroy()
        
        ttk.Button(button_frame, text="Add", command=add_vulnerability).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side=tk.RIGHT)
    
    def delete_vulnerability(self, tree_view):
        selected = tree_view.selection()
        if not selected:
            messagebox.showinfo("No Selection", "Please select a vulnerability to delete.")
            return
        
        if not messagebox.askyesno("Confirm Delete", "Are you sure you want to delete the selected vulnerability?"):
            return
        
        item = tree_view.item(selected[0])
        banner = item['values'][0]
        
        if banner in self.scanner.vuln_db.local_db:
            del self.scanner.vuln_db.local_db[banner]
            self.scanner.vuln_db.save_local_database()
        
        tree_view.delete(selected[0])
    
    def search_vulnerabilities(self, query, results_widget):
        if not query:
            messagebox.showinfo("Empty Query", "Please enter a search term.")
            return
        
        results_widget.delete("1.0", tk.END)
        results_widget.insert(tk.END, f"Searching for '{query}'...\n\n")
        
        def perform_search():
            try:
                time.sleep(1)
                
                api_results = [
                    {
                        "cve": f"CVE-2024-{randint(1000, 9999)}",
                        "description": f"Vulnerability in {query} allowing remote code execution",
                        "severity": "HIGH",
                        "published": "2024-03-15"
                    },
                    {
                        "cve": f"CVE-2023-{randint(1000, 9999)}",
                        "description": f"Buffer overflow in {query} may lead to denial of service",
                        "severity": "MEDIUM",
                        "published": "2023-11-22"
                    },
                    {
                        "cve": f"CVE-2022-{randint(1000, 9999)}",
                        "description": f"Information disclosure vulnerability in {query}",
                        "severity": "LOW",
                        "published": "2022-08-07"
                    }
                ]
                
                self.after(0, lambda: update_results(api_results))
            except Exception as e:
                self.after(0, lambda: results_widget.insert(tk.END, f"Error: {str(e)}\n"))
        
        def update_results(api_results):
            results_widget.delete("1.0", tk.END)
            
            if api_results:
                results_widget.insert(tk.END, f"Found {len(api_results)} results:\n\n")
                
                for result in api_results:
                    results_widget.insert(tk.END, f"CVE: {result['cve']}\n")
                    results_widget.insert(tk.END, f"Severity: {result['severity']}\n")
                    results_widget.insert(tk.END, f"Published: {result['published']}\n")
                    results_widget.insert(tk.END, f"Description: {result['description']}\n")
                    results_widget.insert(tk.END, "\n" + "-"*50 + "\n\n")
            else:
                results_widget.insert(tk.END, "No vulnerabilities found.")
        
        threading.Thread(target=perform_search).start()
    
    def show_preferences(self):
        dialog = tk.Toplevel(self)
        dialog.title("Preferences")
        dialog.geometry("400x300")
        dialog.minsize(400, 300)
        dialog.transient(self)
        dialog.grab_set()
        
        notebook = ttk.Notebook(dialog)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        scan_frame = ttk.Frame(notebook, padding=10)
        notebook.add(scan_frame, text="Scanning")
        
        ttk.Label(scan_frame, text="Connection Timeout (seconds):").grid(row=0, column=0, sticky=tk.W, pady=5)
        timeout_var = tk.StringVar(value="1")
        ttk.Spinbox(scan_frame, from_=1, to=10, textvariable=timeout_var, width=5).grid(row=0, column=1, sticky=tk.W, pady=5)
        
        ttk.Label(scan_frame, text="Max Threads:").grid(row=1, column=0, sticky=tk.W, pady=5)
        threads_var = tk.StringVar(value="100")
        ttk.Spinbox(scan_frame, from_=10, to=500, textvariable=threads_var, width=5).grid(row=1, column=1, sticky=tk.W, pady=5)
        
        ttk.Label(scan_frame, text="Default Port Range:").grid(row=2, column=0, sticky=tk.W, pady=5)
        port_frame = ttk.Frame(scan_frame)
        port_frame.grid(row=2, column=1, sticky=tk.W, pady=5)
        
        start_port_var = tk.StringVar(value="1")
        end_port_var = tk.StringVar(value="1024")
        ttk.Entry(port_frame, textvariable=start_port_var, width=6).pack(side=tk.LEFT)
        ttk.Label(port_frame, text="-").pack(side=tk.LEFT, padx=2)
        ttk.Entry(port_frame, textvariable=end_port_var, width=6).pack(side=tk.LEFT)
        
        report_frame = ttk.Frame(notebook, padding=10)
        notebook.add(report_frame, text="Reporting")
        
        ttk.Label(report_frame, text="Default Report Format:").grid(row=0, column=0, sticky=tk.W, pady=5)
        format_var = tk.StringVar(value="HTML")
        ttk.Combobox(report_frame, textvariable=format_var, values=["HTML", "CSV", "TXT"]).grid(row=0, column=1, sticky=tk.W, pady=5)
        
        ttk.Label(report_frame, text="Default Save Location:").grid(row=1, column=0, sticky=tk.W, pady=5)
        location_var = tk.StringVar(value=os.path.expanduser("~"))
        location_frame = ttk.Frame(report_frame)
        location_frame.grid(row=1, column=1, sticky=tk.W, pady=5)
        
        ttk.Entry(location_frame, textvariable=location_var, width=25).pack(side=tk.LEFT, padx=(0, 5))
        ttk.Button(location_frame, text="Browse", command=lambda: location_var.set(filedialog.askdirectory())).pack(side=tk.LEFT)
        
        screenshots_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(report_frame, text="Include Vulnerability References", variable=screenshots_var).grid(row=2, column=0, columnspan=2, sticky=tk.W, pady=5)
        
        button_frame = ttk.Frame(dialog)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(button_frame, text="Save", command=dialog.destroy).pack(side=tk.RIGHT, padx=(5, 0))
        ttk.Button(button_frame, text="Cancel", command=dialog.destroy).pack(side=tk.RIGHT)
    
    def show_documentation(self):
        doc_window = tk.Toplevel(self)
        doc_window.title("Vulnerability Scanner Documentation")
        doc_window.geometry("800x600")
        doc_window.minsize(600, 400)
        
        text_widget = scrolledtext.ScrolledText(doc_window, wrap=tk.WORD, font=("Arial", 11))
        text_widget.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        doc_content = """# Advanced Vulnerability Scanner
## User Guide

### Introduction
The Advanced Vulnerability Scanner is a comprehensive tool for identifying security vulnerabilities in network services. 
It combines port scanning, banner grabbing, and vulnerability detection to provide actionable security insights.

### Features
- Network discovery
- Port scanning with banner grabbing
- Vulnerability detection using local and online databases
- Detailed reporting in multiple formats
- Intuitive graphical user interface
- Statistical analysis of scan results

### Getting Started
1. Enter a target IP address or network range (CIDR notation)
2. Specify the port range to scan
3. Click "Start Scan" to begin the scanning process
4. Review results in the various tabs

### Scanning Options
- **Single IP**: Enter a specific IP address (e.g., 192.168.1.100)
- **Network Range**: Enter a CIDR notation (e.g., 192.168.1.0/24)
- **Port Range**: Specify start and end ports to scan

### Interpreting Results
- Open ports are listed with their associated services
- Detected vulnerabilities are highlighted based on severity
- The Statistics tab provides an overview of vulnerability distribution

### Exporting Reports
1. Go to File > Export Results
2. Choose the desired format (HTML, CSV, or TXT)
3. Specify the save location
4. Review the generated report

### Best Practices
- Always obtain permission before scanning systems you don't own
- Regularly update the vulnerability database
- Use the tool responsibly and ethically
- Follow up on detected vulnerabilities with appropriate remediation

### Troubleshooting
- If scans are slow, try reducing the port range or number of targets
- If connection errors occur, check network connectivity
- For false positives, verify vulnerabilities with additional testing
"""
        
        text_widget.insert(tk.END, doc_content)
        text_widget.config(state=tk.DISABLED)
    
    def show_about(self):
        about_text = """Advanced Vulnerability Scanner
Version 1.0.0

Created by: BishalMahato
Date: 2025-07-26

A powerful and easy-to-use tool for discovering security vulnerabilities 
in network services. This application is designed for security professionals, 
system administrators, and cybersecurity enthusiasts.

THIS SOFTWARE IS PROVIDED FOR EDUCATIONAL PURPOSES ONLY.
Use responsibly and only on systems you own or have permission to scan."""
        
        messagebox.showinfo("About", about_text)

if __name__ == "__main__":
    try:
        app = VulnerabilityScanner()
        app.mainloop()
    except Exception as e:
        print(f"Error starting application: {e}")
